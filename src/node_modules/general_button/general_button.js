const STATE = require('STATE')
const statedb = STATE(__filename)
const { sdb, get } = statedb(fallback_module)

const switch_account = require('switch_account')  // ✅ require here

module.exports = general_button

async function general_button (opts = {}, protocol) {
  const { id, sdb } = await get(opts.sid)
  const { drive } = sdb

  const on = {
    style: inject,
    data: ondata
  }

  const el = document.createElement('div')
  const shadow = el.attachShadow({ mode: 'closed' })

  shadow.innerHTML = `
    <div class="general-button-container">
      <button class="general-button" type="button">
        <span class="button-text">Button</span>
      </button>
    </div>
    <style></style>
  `

  const style = shadow.querySelector('style')
  const button = shadow.querySelector('.general-button')

  let send_action = null
  if (protocol) {
    send_action = protocol(msg => on_message(msg))
  }

  // Set up click handler
  button.addEventListener('click', handle_click)

  await sdb.watch(onbatch)

  return el

  // ------------------------- Helpers -------------------------

  function fail(data, type) { throw new Error('invalid message', { cause: { data, type } }) }

  async function onbatch (batch) {
    for (const { type, paths } of batch) {
      const data = await Promise.all(paths.map(path => drive.get(path).then(file => file.raw)))
      const func = on[type] || fail
      func(data, type)
    }
  }

  function inject (data) {
    style.textContent = data[0]
  }

  function ondata(data) {
    const buttonData = data[0]?.value || {}
    const { name, action } = buttonData
    console.log(`name "${name}"`)
    update_button(buttonData)
  }

  function on_message({ type, data }) {
    if (type === 'button_name') {
      console.log(`Button "${data.name}", action "${data.action}"`)
      update_button({
        name: data.name,
        action: data.action
      })
    }
  }

  function update_button({ name = 'Button', disabled = false, action = null }) {
    const buttonTextEl = shadow.querySelector('.button-text')

    if (buttonTextEl) {
      buttonTextEl.textContent = name
    }

    if (button) {
      button.disabled = disabled
      button._action = action // Store action for use when clicked
    }
  }

  async function handle_click(event) {
    event.preventDefault()

    if (button._action === 'wallet_action') {
      console.log('Wallet button clicked - opening switch_account')

      const subs = await sdb.watch(onbatch)

      // ✅ load switch_account UI (with fallback support)
      const switchEl = await switch_account(subs[0])

      const container = document.createElement('div')
      container.className = 'switch-account-container'
      container.appendChild(switchEl)
      shadow.appendChild(container)
      return
    }

    if (send_action && button._action) {
      send_action({
        type: button._action,
        data: {
          text: shadow.querySelector('.button-text').textContent
        }
      })
    }
  }
}

// ============ Fallback Setup for STATE ============


function fallback_module() {
  return {
    api,
    _: {
      'switch_account': { $: '' },
    }
  }

  function api(opts) {

    const switch_account = {
      mapping: {
        style: 'style',
        data: 'data',
        icons: 'icons'
      },
      0:{
        value: {
          btc: 0.9862,
          lightning: 0.9000
        },
      },
    }

    return {
      drive: {
        'style/': {
          'general_button.css': {
            '$ref': 'general_button.css'
          }
        },
        'data/': {
          'opts.json': {
            raw: opts
          }
        }
      },
      _: {
        switch_account
   
      }
    }
  }
}

