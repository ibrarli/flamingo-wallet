const STATE = require('STATE')
const statedb = STATE(__filename)
const { sdb, get } = statedb(fallback_module)

const general_button = require('general_button')
const switch_account = require('switch_account')

module.exports = wallet_button

async function wallet_button(opts = {}, protocol) {
  const { id, sdb } = await get(opts.sid)
  const { drive } = sdb

  const _ = { wallet_general: null }

  const el = document.createElement('div')
  const shadow = el.attachShadow({ mode: 'closed' })

  shadow.innerHTML = `
    <div class="wallet-buttons wallet-button-container" id="wallet-button-container">
        <div class="dropdown-container hidden"></div>
    </div>
    <style></style>
  `

  const style = shadow.querySelector('style')
  const wallet_container = shadow.querySelector('#wallet-button-container')
  const wallet_dropdown = wallet_container.querySelector('.dropdown-container')

  // -------------------- on object --------------------
  const on = {
    style: inject,
    data: ondata
  }

  const subs = await sdb.watch(onbatch)

  // sendUp function from parent
  const sendUp = protocol ? protocol((msg) => {
    console.log('[wallet_button] message from parent ->', msg)
  }) : null

  // -------------------- Create Wallet Button --------------------
  const wallet_btn = await general_button(subs[0], button_protocol('wallet_general'))
  wallet_container.insertBefore(wallet_btn, wallet_dropdown)
  wallet_btn._action = 'wallet_action'

  let switch_el = null

  function close_dropdown() {
    wallet_dropdown.classList.add('hidden')
  }

  wallet_btn.onclick = async (event) => {
    event.stopPropagation()
    if (wallet_btn._action !== 'wallet_action') return

    if (!wallet_dropdown.classList.contains('hidden')) {
      close_dropdown()
      return
    }

    if (!switch_el) {
      const switchProtocol = (sendToSwitch) => (msgFromSwitch) => {
        const forwarded = { from: 'switch_account', ...msgFromSwitch }
        if (sendUp) sendUp(forwarded)
      }

      switch_el = await switch_account(subs[1], switchProtocol)
      wallet_dropdown.appendChild(switch_el)
    }

    wallet_dropdown.classList.remove('hidden')
  }

  // -------------------- Initial Config --------------------
  _.wallet_general?.({
    type: 'button_name',
    data: { name: 'Wallet', action: 'wallet_action' }
  })

  // -------------------- Return element --------------------
  return el

  // ------------------------- Helpers -------------------------
  function fail(data, type) {
    throw new Error('Invalid message type', { cause: { data, type } })
  }

  async function onbatch(batch) {
    for (const { type, paths } of batch) {
      const data = await Promise.all(
        paths.map(path => drive.get(path).then(file => file.raw))
      )
      const handler = on[type] || fail
      handler(data, type)
    }
  }

  function inject(data) {
    style.textContent = data[0]
  }

  async function ondata(data) {
    const buttonData = data[0]?.value || {}
    // can handle button-specific updates here if needed
  }

  function button_protocol(key) {
    return send => {
      _[key] = send
      return send
    }
  }
}

// ============ Fallback Setup ============
function fallback_module() {
  return {
    api,
    _: {
      'general_button': { $: '' },
      'switch_account': { $: '' }
    }
  }

  function api(opts) {
    const general_button = {
      mapping: { style: 'style', data: 'data' },
      0: {} // wallet button
    }

    const switch_account = {
      mapping: { style: 'style', data: 'data', icons: 'icons' },
      1: { btc: 0.789, lightning: 0.9 }
    }

    return {
      drive: {
        'style/': { 'wallet_button.css': { '$ref': 'wallet_button.css' } },
        'data/': { 'opts.json': { raw: opts } }
      },
      _: { general_button, switch_account }
    }
  }
}