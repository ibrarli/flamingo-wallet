const STATE = require('STATE')
const statedb = STATE(__filename)
const { sdb, get } = statedb(fallback_module)

const search_bar = require('search_bar') 
const square_button = require('square_button') 
const contact_row = require('contact_row')

module.exports = contacts_list

async function contacts_list(opts = {}) {
  const { id, sdb } = await get(opts.sid)
  const { drive } = sdb

  const el = document.createElement('div')
  const shadow = el.attachShadow({ mode: 'closed' })

  shadow.innerHTML = `
    <div class="contact-list-container">
      <div class="contact-list-header">Contacts</div>
      <div class="top-bar"></div>
    </div>
    <style></style>
  `
  const style = shadow.querySelector('style')
  const top_bar = shadow.querySelector('.top-bar')
  const contact_list_container = shadow.querySelector('.contact-list-container')

  const subs = await sdb.watch(onbatch)

  const contactElements = []

if (subs.length > 0) {
  const search = await search_bar(subs[0], msg => {
    if (msg.type === 'search') {
      const value = msg.value.toLowerCase()
      console.log('[SearchBar] search value typed:', value) // <-- added log

      contactElements.forEach(({ el, name }) => {
        const isVisible = name.toLowerCase().includes(value)
        console.log(`[SearchBar] checking contact: "${name}", visible: ${isVisible}`) // <-- added log
        el.style.display = isVisible ? '' : 'none'
      })
    }
  })

  const button = await square_button(subs[1])
  top_bar.append(search)
  top_bar.append(button)
}
for (let i = 2; i < subs.length; i++) {
  const contactData = subs[i]
  let contactEl // declare first
  const protocol = msg => {
    if (msg.type === 'contact-name') {
      console.log('[ContactList] contact name received:', msg.name)
      
      // update contactElements safely
      let elObj = contactElements.find(c => c.el === contactEl)
      if (!elObj) contactElements.push({ el: contactEl, name: msg.name })
      else elObj.name = msg.name
    }
  }

  contactEl = await contact_row(contactData, protocol)
  contact_list_container.append(contactEl)
}

  return el

  function fail(data, type) { throw new Error('invalid message', { cause: { data, type } }) }
  async function onbatch(batch) { 
    for (const { type, paths } of batch) {
      const data = await Promise.all(paths.map(path => drive.get(path).then(f => f.raw)))
      // ondata or style injection handled in individual modules
    }
  }
}
function fallback_module() {
  return {
    api,
    _: {
      'search_bar': { $: '' },
      'contact_row': { $: '' },
      'square_button': { $: '' }
    }
  }

  function api(opts) {
    const search_bar = { mapping: { style: 'style', data: 'data', icons: 'icons' }, 0: {} }
    const square_button = { mapping: { style: 'style', data: 'data', icons: 'icons' }, 1: {} }
    const contact_row = { mapping: { style: 'style', data: 'data', icons: 'icons' } }

    opts.value.forEach((contact, index) => {
      contact_row[index + 2] = contact
    })

    return {
      drive: {
        'style/': { 'contacts_list.css': { '$ref': 'contacts_list.css' } },
        'data/': { 'opts.json': { raw: opts } }
      },
      _: { search_bar, square_button, contact_row }
    }
  }
}