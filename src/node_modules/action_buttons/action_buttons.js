const STATE = require('STATE')
const statedb = STATE(__filename)
const { sdb, get } = statedb(fallback_module)

const general_button = require('general_button')
const send_btc = require('send_btc')
const receive_btc = require('receive_btc')

module.exports = action_buttons

async function action_buttons(opts = {}, protocol) {
  const { id, sdb } = await get(opts.sid)
  const { drive } = sdb

  const on = {
    style: inject,
    data: ondata
  }

  const _ = {
    send_general: null,
    receive_general: null
  }

  const el = document.createElement('div')
  const shadow = el.attachShadow({ mode: 'closed' })

  shadow.innerHTML = `
    <div class="action-buttons-container">
        <div class="send-receive-buttons">
            <div id="send-button-container">
              <div class="send-dropdown hidden"></div>
            </div> 
            <div id="receive-button-container">
              <div class="receive-dropdown hidden"></div>
            </div> 
        </div>
    </div>
    <style></style>
  `

  const style = shadow.querySelector('style')
  const send_dropdown = shadow.querySelector('.send-dropdown')
  const receive_dropdown = shadow.querySelector('.receive-dropdown')

  const subs = await sdb.watch(onbatch)

  const sendUp = protocol ? protocol((msgToActionButtons) => {
    console.log('[action_buttons] message from parent ->', msgToActionButtons)
  }) : null

  // Create buttons
  const send_button = await general_button(subs[0])
  const receive_button = await general_button(subs[1], button_protocol('receive_general'))

  shadow.querySelector('#send-button-container').prepend(send_button)
  shadow.querySelector('#receive-button-container').prepend(receive_button)

  send_button._action = 'send_message'
  receive_button._action = 'receive_message'

  let send_el = null
  let receive_el = null

  function close_all_dropdowns(except) {
    if (except !== 'send') send_dropdown.classList.add('hidden')
    if (except !== 'receive') receive_dropdown.classList.add('hidden')
  }

  function handle_outside_click(event) {
    const target = event.target
    const clicked_inside_dropdown =
      send_dropdown.contains(target) ||
      receive_dropdown.contains(target)
    const clicked_button =
      send_button.contains(target) ||
      receive_button.contains(target)

    if (!clicked_inside_dropdown && !clicked_button) {
      close_all_dropdowns(null)
    }
  }

  shadow.addEventListener('click', handle_outside_click)

  // -------------------- Dropdown Toggles --------------------

  // Send button
  send_button.onclick = async (event) => {
    event.stopPropagation()
    if (send_button._action !== 'send_message') return

    if (!send_dropdown.classList.contains('hidden')) {
      send_dropdown.classList.add('hidden')
      return
    }

    close_all_dropdowns('send')

    if (!send_el) {
      send_el = await send_btc(subs[2], {
        onClose: () => send_dropdown.classList.add('hidden')
      })
      send_dropdown.appendChild(send_el)
    }

    send_dropdown.classList.remove('hidden')
  }

  // Receive button
  receive_button.onclick = async (event) => {
    event.stopPropagation()
    if (receive_button._action !== 'receive_message') return

    if (!receive_dropdown.classList.contains('hidden')) {
      receive_dropdown.classList.add('hidden')
      return
    }

    close_all_dropdowns('receive')

    if (!receive_el) {
      receive_el = await receive_btc(subs[3], {
        onClose: () => receive_dropdown.classList.add('hidden')
      })
      receive_dropdown.appendChild(receive_el)
    }

    receive_dropdown.classList.remove('hidden')
  }

  // -------------------- Initial Config --------------------

  _.send_general?.({
    type: 'button_name',
    data: { name: 'Send', action: 'send_message' }
  })

  _.receive_general?.({
    type: 'button_name',
    data: { name: 'Receive', action: 'receive_message' }
  })

  return el

  // ------------------------- Helpers -------------------------

  function fail(data, type) {
    throw new Error('Invalid message type', { cause: { data, type } })
  }

  async function onbatch(batch) {
    for (const { type, paths } of batch) {
      const data = await Promise.all(
        paths.map(path => drive.get(path).then(file => file.raw))
      )
      const handler = on[type] || fail
      handler(data, type)
    }
  }

  function inject(data) {
    style.textContent = data[0]
  }

  async function ondata(data) {
    const buttonData = data[0]?.value || {}
  }

  function button_protocol(key) {
    return send => {
      _[key] = send
      return send
    }
  }

  // Action handlers
  function send_message(data, type) {
  }

  function receive_message(data, type) {
  }
}

// ============ Fallback Setup for STATE ============
function fallback_module() {
  return {
    api,
    _: {
      'general_button': { $: '' },
      'send_btc': { $: '' },
      'receive_btc': { $: '' }
    }
  }

  function api(opts) {
    const general_button = {
      mapping: { style: 'style', data: 'data' },
      0: {}, // send button
      1: {}  // receive button
    }

    const send_btc = { mapping: { style: 'style', data: 'data', icons: 'icons' }, 2: '' }
    const receive_btc = { mapping: { style: 'style', data: 'data', icons: 'icons' }, 3: '' }

    return { drive: { 'style/': { 'action_buttons.css': { '$ref': 'action_buttons.css' } } }, _: { general_button, send_btc, receive_btc } }
  }
}