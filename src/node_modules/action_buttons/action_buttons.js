const STATE = require('STATE')
const statedb = STATE(__filename)
const { sdb, get } = statedb(fallback_module)

const general_button = require('general_button')

module.exports = action_buttons

async function action_buttons (opts = {}, protocol) {
  const { id, sdb } = await get(opts.sid)
  const { drive } = sdb

  const on = {
    style: inject,
    data: ondata
  }

  const _ = {
    up: null,
    send_general: null,
    receive_general: null,
    wallet_general: null
  }

  const el = document.createElement('div')
  const shadow = el.attachShadow({ mode: 'closed' })

  shadow.innerHTML = `
    <div class="action-buttons-container">
        <div class="wallet-buttons">
            <div id="wallet-button-container"></div>
        </div>
        <div class="send-receive-buttons">
            <div id="send-button-container"></div> 
            <div id="receive-button-container"></div> 
        </div>
    </div>
    <style></style>
    `


  const style = shadow.querySelector('style')

  const subs = await sdb.watch(onbatch)

  if (protocol) {
    protocol({ from: 'action_buttons', notify: on_message })
  }

  const sendButton = await general_button(subs[0], button_protocol('send_general'))
  const receiveButton = await general_button(subs[1], button_protocol('receive_general'))
  const walletButton = await general_button(subs[2], button_protocol('wallet_general'))

  shadow.querySelector('#send-button-container').replaceWith(sendButton)
  shadow.querySelector('#receive-button-container').replaceWith(receiveButton)
  shadow.querySelector('#wallet-button-container').replaceWith(walletButton)

  _.send_general?.({
    type: 'button_name',
    data: {
      name: 'Send',
      action: 'send_message'
    }
  })

  _.receive_general?.({
    type: 'button_name',
    data: {
      name: 'Receive',
      action: 'receive_message'
    }
  })

  _.wallet_general?.({
    type: 'button_name',
    data: {
      name: 'Wallet',
      action: 'wallet_action'
    }
  })

  const action = {
    send_message,
    receive_message,
    wallet_action
  }

  return el

  // ------------------------- Helpers -------------------------

  function fail (data, type) {
    throw new Error('Invalid message type', { cause: { data, type } })
  }

  async function onbatch (batch) {
    for (const { type, paths } of batch) {
      const data = await Promise.all(paths.map(path => drive.get(path).then(file => file.raw)))
      const handler = on[type] || fail
      handler(data, type)
    }
  }

  function inject (data) {
    style.textContent = data[0]
  }

  async function ondata (data) {
    const buttonData = data[0]?.value || {}
    // handle incoming button data here 
  }

  function button_protocol (key) {
    return send => {
      _[key] = send
      return on
    }
  }

  function on_message (message) {
    const { type, data } = message
    ;(action[type] || fail)(data, type)
  }



  function send_message (data, type) {
    console.log('Send button clicked - handling send action')
    // send logic
  }

  function receive_message (data, type) {
    console.log('Receive button clicked - handling receive action')
    // receive logic 
  }

  function wallet_action (data, type) {
    console.log('Wallet button clicked - handling wallet action')
    //wallet logic 
  }
}

// ============ Fallback Setup for STATE ============

function fallback_module () {
  return {
    _: {
      'general_button': {
        $: ''
      }
    },
    api: fallback_instance
  }

  function fallback_instance (opts = {}) {
    return {
      _: {
        'general_button': {
          0: '',
          1: '',
          2: '',
          mapping: {
            style: 'style',
            data: 'data'
          }
        }
      },
      drive: {
        'style/': {
          'action_buttons.css': {
            '$ref': 'action_buttons.css'
          }
        },
        'data/': {
          'opts.json': {
            raw: opts
          }
        }
      }
    }
  }
}