const STATE = require('STATE')
const state_db = STATE(__filename)
const { sdb, get } = state_db(fallback_module)

module.exports = btc_req_msg

async function btc_req_msg(opts = {}) {
  const { id, sdb } = await get(opts.sid)
  const { drive } = sdb

  const on = {
    style: inject_style,
    data: render_data,
    icons: iconject,
  }

  const el = document.createElement('div')
  const shadow = el.attachShadow({ mode: 'closed' })
  shadow.innerHTML = `
    <div class="receipt-card">
      <div class="receipt-header">
        <div class="title-container">
          <div class="receipt-title">Pending Request</div>
          <div class="light-icon-small"></div>
        </div>
        <div class="x-icon"></div>
      </div>
      <div class="btc_req_wrapper"></div>
    </div>
    <style></style>
  `

  const style = shadow.querySelector('style')
  const wrapper = shadow.querySelector('.btc_req_wrapper')
  let dricons = []

  const closeBtn = shadow.querySelector('.x-icon')
  if (closeBtn) {
    closeBtn.onclick = () => {
      const dropdown = el.parentNode
      if (dropdown) {
        dropdown.classList.add('hidden')   
      }
    }
  }

  await sdb.watch(on_batch)
  return el

  function throw_error(data, type) {
    throw new Error('invalid message', { cause: { data, type } })
  }

  

  async function on_batch(batch) {
    for (const { type, paths } of batch) {
      const data = await Promise.all(
        paths.map(path => drive.get(path).then(file => file.raw))
      )
      const fn = on[type] || throw_error
      await fn(data, type)
    }
  }

  function inject_style(data) {
    style.textContent = data[0]
  }


  function iconject(data) {
    dricons = data
    const closeIcon = shadow.querySelector('.x-icon')
    closeIcon.innerHTML = dricons[0]                  
  }

  function render_data(data) {
    const {name, amount, date, is_me } = data[0]

    // Helper to build each variant box
    function render_variant(label, border_color, bg_color, btn_color) {
      return `
        <div class="btc_row ${is_me ? 'self' : ''}">
          <div class="btc_box" style="border:2px solid ${border_color}; background:${bg_color}">
            <div class="btc_top">
              <span>
                <span class="name_text">${name}</span>
                <span class="req_text"> requests </span>
                <span class="amount_text">BTC ${amount} </span>
              </span>
            </div>
            <div class="btc_bottom">
              <span class="btc_expire">Expire at ${date}</span>
              <button class="status_btn" style="background:${btn_color};">${label}</button>
            </div>
          </div>
        </div>

      `
    }

    // Always show all three variants
    wrapper.innerHTML = `
      ${render_variant('Pay', '#DDB473', '#FFFCE7', '#F7931A')}
      ${render_variant('Pay', '#DDB473', '#FFFCE7', '#F7931A')}
      ${render_variant('Pay', '#DDB473', '#FFFCE7', '#F7931A')}
    `
  }
}

function fallback_module() {
  return {
    api: fallback_instance,
  }

  function fallback_instance(opts) {
    if (!opts) opts = {}
    if (!opts.value) opts.value = {}
    return {
      drive: {
        'icons/': {
          'x.svg': {
            '$ref': 'x.svg'
          }
        },
        'style/': {
          'pending_request.css': {
            '$ref': 'pending_request.css'
          }
        },
        'data/': {
          'opts.json': { raw: opts || {}   }
        }
      }
    }
  }
}