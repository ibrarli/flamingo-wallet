const STATE = require('STATE')
const statedb = STATE(__filename)
const { sdb, get } = statedb(fallback_module)

const general_button = require('general_button')
const switch_account = require('switch_account')
const pay_invoice = require('pay_invoice')      
const create_invoice = require('create_invoice')   // changed here ✅

module.exports = lightning_buttons

async function lightning_buttons (opts = {}, protocol) {
  const { id, sdb } = await get(opts.sid)
  const { drive } = sdb

  const on = {
    style: inject,
    data: ondata
  }

  const _ = {
    pay_general: null,
    create_general: null,
    wallet_general: null
  }

  const el = document.createElement('div')
  const shadow = el.attachShadow({ mode: 'closed' })

  shadow.innerHTML = `
    <div class="lightning-buttons-container">
        <div class="wallet-buttons wallet-button-container" id="wallet-button-container">
            <div class="dropdown-container hidden"></div>
        </div>
        <div class="pay-create-buttons">
            <div id="pay-button-container">
              <div class="pay-dropdown hidden"></div>
            </div> 
            <div id="create-button-container">
              <div class="create-dropdown hidden"></div>
            </div> 
        </div>
    </div>
    <style></style>
  `

  const style = shadow.querySelector('style')
  const wallet_container = shadow.querySelector('#wallet-button-container')

  // Dropdown elements
  const wallet_dropdown = wallet_container.querySelector('.dropdown-container')
  const pay_dropdown = shadow.querySelector('.pay-dropdown')
  const create_dropdown = shadow.querySelector('.create-dropdown')

  const subs = await sdb.watch(onbatch)

  if (protocol) {
    protocol({ from: 'lightning_buttons', notify: on_message })
  }

  // Create buttons
  const pay_button = await general_button(subs[0], button_protocol('pay_general'))
  const create_button = await general_button(subs[1], button_protocol('create_general'))
  const wallet_button = await general_button(subs[2], button_protocol('wallet_general'))

  // Insert buttons
  shadow.querySelector('#pay-button-container').prepend(pay_button)
  shadow.querySelector('#create-button-container').prepend(create_button)
  wallet_container.insertBefore(wallet_button, wallet_dropdown)

  // Set default actions
  pay_button._action = 'pay_message'
  create_button._action = 'create_message'
  wallet_button._action = 'wallet_action'

  // Dropdown states
  let pay_el = null
  let create_el = null
  let switch_el = null

  // -------------------- Helpers --------------------

  function close_all_dropdowns(except) {
    if (except !== 'pay') pay_dropdown.classList.add('hidden')
    if (except !== 'create') create_dropdown.classList.add('hidden')
    if (except !== 'wallet') wallet_dropdown.classList.add('hidden')
  }

  function handle_outside_click(event) {
    const target = event.target
    const clicked_inside_dropdown =
      pay_dropdown.contains(target) ||
      create_dropdown.contains(target) ||
      wallet_dropdown.contains(target)

    const clicked_button =
      pay_button.contains(target) ||
      create_button.contains(target) ||
      wallet_button.contains(target)

    if (!clicked_inside_dropdown && !clicked_button) {
      close_all_dropdowns(null)
    }
  }

  shadow.addEventListener('click', handle_outside_click)

  // -------------------- Dropdown Toggles --------------------

  // Pay Invoice button
  pay_button.onclick = async (event) => {
    event.stopPropagation()
    if (pay_button._action !== 'pay_message') return

    if (!pay_dropdown.classList.contains('hidden')) {
      pay_dropdown.classList.add('hidden')
      return
    }

    close_all_dropdowns('pay')

    if (!pay_el) {
      pay_el = await pay_invoice(subs[4], {   // still pay_invoice
        onClose: () => pay_dropdown.classList.add('hidden')
      })
      pay_dropdown.appendChild(pay_el)
    }

    pay_dropdown.classList.remove('hidden')
  }

  // Create Invoice button
  create_button.onclick = async (event) => {
    event.stopPropagation()
    if (create_button._action !== 'create_message') return

    if (!create_dropdown.classList.contains('hidden')) {
      create_dropdown.classList.add('hidden')
      return
    }

    close_all_dropdowns('create')

    if (!create_el) {
      create_el = await create_invoice(subs[5], {   // changed here ✅
        onClose: () => create_dropdown.classList.add('hidden')
      })
      create_dropdown.appendChild(create_el)
    }

    create_dropdown.classList.remove('hidden')
  }

  // Wallet button
  wallet_button.onclick = async (event) => {
    event.stopPropagation()
    if (wallet_button._action !== 'wallet_action') return

    if (!wallet_dropdown.classList.contains('hidden')) {
      wallet_dropdown.classList.add('hidden')
      return
    }

    close_all_dropdowns('wallet')

    if (!switch_el) {
      switch_el = await switch_account(subs[3], {
        onClose: () => wallet_dropdown.classList.add('hidden')
      })
      wallet_dropdown.appendChild(switch_el)
    }

    wallet_dropdown.classList.remove('hidden')
  }

  // -------------------- Initial Config --------------------

  _.pay_general?.({
    type: 'button_name',
    data: { name: 'Pay Invoice', action: 'pay_message' }
  })

  _.create_general?.({
    type: 'button_name',
    data: { name: 'Create Invoice', action: 'create_message' }
  })

  _.wallet_general?.({
    type: 'button_name',
    data: { name: 'Wallet', action: 'wallet_action' }
  })

  const action = {
    pay_message,
    create_message,
    wallet_action
  }

  return el

  // ------------------------- Helpers -------------------------

  function fail (data, type) {
    throw new Error('Invalid message type', { cause: { data, type } })
  }

  async function onbatch (batch) {
    for (const { type, paths } of batch) {
      const data = await Promise.all(
        paths.map(path => drive.get(path).then(file => file.raw))
      )
      const handler = on[type] || fail
      handler(data, type)
    }
  }

  function inject (data) {
    style.textContent = data[0]
  }

  async function ondata (data) {
    const buttonData = data[0]?.value || {}
  }

  function button_protocol (key) {
    return send => {
      _[key] = send
      return send
    }
  }

  function on_message (message) {
    const { type, data } = message
    ;(action[type] || fail)(data, type)
  }

  // Action handlers
  function pay_message (data, type) {
    console.log('Pay Invoice button clicked - handling pay action')
  }

  function create_message (data, type) {
    console.log('Create Invoice button clicked - handling create action')
  }

  function wallet_action (data, type) {
    console.log('Wallet button clicked - handling wallet action')
  }
}

// ============ Fallback Setup for STATE ============
function fallback_module () {
  return {
    api,
    _: {
      'general_button': { $: '' },
      'switch_account': { $: '' },
      'pay_invoice': { $: '' },
      'create_invoice': { $: '' }   // changed here ✅
    }
  }

  function api (opts = {}) {
    const general_button = {
      mapping: {
        style: 'style',
        data: 'data'
      },
      0: {}, // pay button
      1: {}, // create button
      2: {}  // wallet button
    }

    const switch_account = {
      mapping: {
        style: 'style',
        data: 'data',
        icons: 'icons'
      },
      3: {
        btc: 0.789,
        lightning: 0.9000
      } 
    }

    const pay_invoice = {
      mapping: { 
        style: 'style', 
        data: 'data', 
        icons: 'icons' 
      },
      4: ''
    }

    const create_invoice = {   // changed here ✅
      mapping: { 
        style: 'style', 
        data: 'data', 
        icons: 'icons' 
      },
      5: ''
    }

    return {
      drive: {
        'style/': {
          'lightning_buttons.css': { '$ref': 'lightning_buttons.css' }
        },
        'data/': {
          'opts.json': { raw: opts }
        }
      },
      _: { general_button, switch_account, pay_invoice, create_invoice }  // updated here ✅
    }
  }
}
