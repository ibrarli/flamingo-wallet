const STATE = require('STATE')
const statedb = STATE(__filename)
const { sdb, get } = statedb(fallback_module)

const general_button = require('general_button')
const pay_invoice = require('pay_invoice')
const create_invoice = require('create_invoice')

module.exports = lightning_buttons

async function lightning_buttons(opts = {}, protocol) {
  const { id, sdb } = await get(opts.sid)
  const { drive } = sdb

  const on = { style: inject, data: ondata }
  const _ = { pay_general: null, create_general: null }

  const el = document.createElement('div')
  const shadow = el.attachShadow({ mode: 'closed' })

  shadow.innerHTML = `
    <div class="lightning-buttons-container">
        <div class="pay-create-buttons">
            <div id="pay-button-container">
              <div class="pay-dropdown hidden"></div>
            </div> 
            <div id="create-button-container">
              <div class="create-dropdown hidden"></div>
            </div> 
        </div>
    </div>
    <style></style>
  `

  const style = shadow.querySelector('style')
  const pay_dropdown = shadow.querySelector('.pay-dropdown')
  const create_dropdown = shadow.querySelector('.create-dropdown')

  const subs = await sdb.watch(onbatch)

  // -------------------- Protocol setup --------------------
  let sendUp = () => {}
  if (protocol) {
    sendUp = protocol(message => {
      console.log('[lightning_buttons -> home_contents]:', message)
    })
  }

  // -------------------- Create buttons --------------------
  const pay_button = await general_button(subs[0], button_protocol('pay_general'))
  const create_button = await general_button(subs[1], button_protocol('create_general'))

  shadow.querySelector('#pay-button-container').prepend(pay_button)
  shadow.querySelector('#create-button-container').prepend(create_button)

  pay_button._action = 'pay_message'
  create_button._action = 'create_message'

  let pay_el = null, create_el = null

  // -------------------- Helpers --------------------
  function close_all_dropdowns(except) {
    if (except !== 'pay') pay_dropdown.classList.add('hidden')
    if (except !== 'create') create_dropdown.classList.add('hidden')
  }

  function handle_outside_click(event) {
    const target = event.target
    const inside = pay_dropdown.contains(target) || create_dropdown.contains(target)
    const onButton = pay_button.contains(target) || create_button.contains(target)
    if (!inside && !onButton) close_all_dropdowns(null)
  }
  shadow.addEventListener('click', handle_outside_click)

  // -------------------- Button Clicks --------------------
  pay_button.onclick = async (e) => {
    e.stopPropagation()
    if (pay_button._action !== 'pay_message') return
    if (!pay_dropdown.classList.contains('hidden')) { pay_dropdown.classList.add('hidden'); return }
    close_all_dropdowns('pay')
    if (!pay_el) {
      pay_el = await pay_invoice(subs[2], { onClose: () => pay_dropdown.classList.add('hidden') })
      pay_dropdown.appendChild(pay_el)
    }
    pay_dropdown.classList.remove('hidden')

    sendUp({ from: 'lightning_buttons', type: 'pay', data: null })
  }

  create_button.onclick = async (e) => {
    e.stopPropagation()
    if (create_button._action !== 'create_message') return
    if (!create_dropdown.classList.contains('hidden')) { create_dropdown.classList.add('hidden'); return }
    close_all_dropdowns('create')
    if (!create_el) {
      create_el = await create_invoice(subs[3], { onClose: () => create_dropdown.classList.add('hidden') })
      create_dropdown.appendChild(create_el)
    }
    create_dropdown.classList.remove('hidden')

    sendUp({ from: 'lightning_buttons', type: 'create', data: null })
  }

  // -------------------- Initial Config --------------------
  _.pay_general?.({ type: 'button_name', data: { name: 'Pay Invoice', action: 'pay_message' } })
  _.create_general?.({ type: 'button_name', data: { name: 'Create Invoice', action: 'create_message' } })

  const action = { pay_message, create_message }
  return el

  // -------------------- Helpers --------------------
  function fail(data, type) { throw new Error('Invalid message type', { cause: { data, type } }) }
  async function onbatch(batch) {
    for (const { type, paths } of batch) {
      const data = await Promise.all(paths.map(path => drive.get(path).then(f => f.raw)))
      const handler = on[type] || fail
      handler(data, type)
    }
  }
  function inject(data) { style.textContent = data[0] }
  async function ondata(data) { const buttonData = data[0]?.value || {} }
  function button_protocol(key) { return send => { _[key] = send; return send } }

  // -------------------- Action Handlers --------------------
  function pay_message(data, type) { sendUp({ from: 'lightning_buttons', type: 'pay', data }) }
  function create_message(data, type) { sendUp({ from: 'lightning_buttons', type: 'create', data }) }
}

// ------------------ Fallback for STATE ------------------
function fallback_module() {
  return {
    api,
    _: { 'general_button': { $: '' }, 'pay_invoice': { $: '' }, 'create_invoice': { $: '' } }
  }

  function api(opts = {}) {
    const general_button = { mapping: { style: 'style', data: 'data' }, 0: {}, 1: {} }
    const pay_invoice = { mapping: { style: 'style', data: 'data', icons: 'icons' }, 2: '' }
    const create_invoice = { mapping: { style: 'style', data: 'data', icons: 'icons' }, 3: '' }

    return {
      drive: { 'style/': { 'lightning_buttons.css': { '$ref': 'lightning_buttons.css' } }, 'data/': { 'opts.json': { raw: opts } } },
      _: { general_button, pay_invoice, create_invoice }
    }
  }
}